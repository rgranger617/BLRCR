# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

unique_rows <- function(x) {
    .Call('_BLRCR_unique_rows', PACKAGE = 'BLRCR', x)
}

#' Semi-Parametric Bayesian Logistic Regression Capture-Recapture
#' 
#' This function computes MCMC samples of N using the the Bayesian Logistic
#' Regression Capture-Recapture model.
#' 
#' @param formula an object of class "formula".
#' @param df Data containing capture histories and individual covariates.
#' 
#' @param covmethod specify a method for simulating the covariates.  
#' Options include "bootstrap", "mixture", and "empirical".
#' @param coefprior specify a prior for the logistic regression coefficients.
#' Options include "normal" and "horseshoe".
#' 
#' @param bprior vector of hyperparameters for the mean of the coefficient prior. If a single 
#' value is used, it will apply this value for all coefficients. If "normalhier" is selected, it will use
#' these values as the coefficient prior on b.
#' @param Bprior value to assign the diagonals of the covariance matrix B for all variables.
#' 
#' @param Homega the number of latent intercepts
#' @param Kstar an integer of maximum number of mixture classes. This only needs to be specified
#' if the covmethod is "mixture".
#' 
#' @param samples the number of MCMC samples to draw from the posterior.
#' @param burnin the number of MCMC samples to "burn-in."
#' 
#' @return List with CR results. 
#' 
#' @examples
#' #Create the Data
#' mybeta = matrix(c(-2,-1,1,
#'                   -2,1,-1,
#'                   -2,-1,1,
#'                   -2,1,-1),nrow=4,byrow=TRUE)
#'                   
#' mynormprobs=c(0.3,0.4,0.3)
#' 
#' mynormmeans=matrix(c(2,2,
#'                      0,0,
#'                      -2,-2),ncol=2,byrow=TRUE)
#'                      
#' mynormsigma=matrix(c(.5,.45,.45,.5,
#'                       1,0,0,1,
#'                       .5,-.35,-.35,.5),nrow=3,byrow=TRUE)
#' 
#' myCRdata = multdatasimulator(2000,mybeta,mynormprobs,mynormmeans,mynormsigma,
#'                            missing=TRUE)
#'                            
#' #Run the Algorithm
#' myformula = cbind(y1,y2,y3,y4)~x1+x2
#' 
#' CRresults = BLRCRsolver(myformula,myCRdata,covmethod="mixture",coefprior="normal",
#'                         Homega=10,Kstar=10, samples=1000)                     
#' 
#' @export 
BLRCRsolver <- function(formula, df, covmethod = "bootstrap", coefprior = "normal", bprior = 0L, Bprior = 1, Homega = 1L, Kstar = 1L, samples = 1000L, burnin = 0L) {
    .Call('_BLRCR_BLRCRsolver', PACKAGE = 'BLRCR', formula, df, covmethod, coefprior, bprior, Bprior, Homega, Kstar, samples, burnin)
}

#' Bayesian Logistic Regression Capture-Recapture with Missing Covariate Values
#' 
#' This function computes MCMC samples of N using the the Bayesian Logistic
#' Regression Capture-Recapture model but can also handle missing covariate values.
#' This method only allows for "bootstrap" and "empirical" covariate methods.
#' 
#' @param formula an object of class "formula".
#' @param df data containing capture histories and individual covariates.
#' 
#' @param covsupport specify a method for generating the support of the bootstrap distribution.  
#' Options include "all" and "unique".
#' @param covmethod specify a method for the distribution of the covariates.  
#' Options include "bootstrap" and "empirical".
#' @param coefprior specify a prior for the logistic regression coefficients.
#' Options include "normal", "normalhier", "normalhiervaronly", and "lasso".
#' 
#' @param bprior vector of hyperparameters for the mean of the coefficient prior. If a single 
#' value is used, it will apply this value for all coefficients. If "normalhier" is selected, it will use
#' these values as the coefficient prior on b.
#' @param Bprior value to assign the diagonals of the covariance matrix B for the observed variables.
#' @param LBprior value to assign the diagonals of the covariance matrix B for the latent variables.
#' 
#' @param alphaomega a value for the concentration parameter. Leave blank to apply a prior distribution
#' to the concentration parameter of Gamma(aomega,bomega).
#' @param aomega a value for the hyperparameter on the concentration parameter.
#' @param bomega a value for the hyperparameter on the concentration parameter.
#' 
#' @param Homega the number of latent intercepts
#' 
#' @param samples the number of MCMC samples to draw and return from the posterior.
#' @param burnin the number of MCMC samples to "burn-in."
#' @param thinning the number of MCMC samples to "thin".
#' 
#' @return 
#' \describe{
#' \item{"samples"}{is the number of samples.} 
#' \item{"H"}{is the number of covariate values after transformations} 
#' \item{"n"}{is the number of observed individuals in the data.}
#' \item{"N"}{is a sample of population sizes from the posterior distribution.}
#' \item{"Xmis"}{is a sample of missing covariate values. One of each covariate is sampled and saved
#' at each sampling occasion.}
#' \item{"alphaomega"}{is a sample of alphaomega values from the posterior.}
#' \item{"Beta"}{is a sample of JxH+Homega matrices of beta coefficients.}
#' \item{"Betacolnames"}{The names of the covariates for each column of the beta coefficients.}
#' \item{"PSIMATRIX"}{}
#' \item{"PSICOUNTS"}{}
#' \item{"PHIomega"}{}
#' \item{"omegalabels"}{}
#' \item{"priorBdiag"}{}
#' \item{"probcaptured"}{}
#' \item{"loglikelihood"}{}
#' \item{"BIC"}{}
#' }
#' 
#' 
#' @examples
#' #Create the Data
#' mybeta = matrix(c(-2,-1,1,
#'                   -2,1,-1,
#'                   -2,-1,1,
#'                   -2,1,-1),nrow=4,byrow=TRUE)
#'                   
#' mynormprobs=c(0.3,0.4,0.3)
#' 
#' mynormmeans=matrix(c(2,2,
#'                      0,0,
#'                      -2,-2),ncol=2,byrow=TRUE)
#'                      
#' mynormsigma=matrix(c(.5,.45,.45,.5,
#'                       1,0,0,1,
#'                       .5,-.35,-.35,.5),nrow=3,byrow=TRUE)
#' 
#' myCRdata = multdatasimulator(2000,mybeta,mynormprobs,mynormmeans,mynormsigma,
#'                            missing=TRUE)
#'                            
#' #Run the Algorithm
#' myformula = cbind(y1,y2,y3,y4)~x1+x2
#' 
#' CRresults=BLRCRsolvermissing(myformula,df=myCRdata,Homega=1,
#'                              Bprior=1,LBprior=1,
#'                              covsupport="unique",
#'                              samples = 1000,burnin=10,thinning = 10)
#' 
#' 
#' @export 
BLRCRsolvermissing <- function(formula, df, covmethod = "bootstrap", covsupport = "unique", coefprior = "normal", bprior = NULL, Bprior = 1, LBprior = 1, alphabayesbootstrap = 0, alphaomega = NULL, aomega = 0.25, bomega = 0.25, Homega = 1L, samples = 1000L, burnin = 0L, thinning = 1L) {
    .Call('_BLRCR_BLRCRsolvermissing', PACKAGE = 'BLRCR', formula, df, covmethod, covsupport, coefprior, bprior, Bprior, LBprior, alphabayesbootstrap, alphaomega, aomega, bomega, Homega, samples, burnin, thinning)
}

#' Semi-Parametric Bayesian Logistic Regression Capture-Recapture
#' 
#' This function computes MCMC samples of N using the the Bayesian Logistic
#' Regression Capture-Recapture model.
#' 
#' @param y a nxJ matrix of capture patterns.
#' @param x a nxH matrix of covariates.
#' @param beta a (H+1) vector of prior means for the coefficients
#' 
#' @return List with components "N" and "beta". 
#' \describe{
#' \item{"N"}{is a single estimate of the population size.}
#' \item{"beta"}{is a matrix of beta estimates.}
#' }
#' 
#' @examples
#' #Generate the Data
#' mybeta = matrix(c(-2,-1,1,
#'                   -2,1,-1,
#'                   -2,-1,1,
#'                   -2,1,-1),nrow=4,byrow=TRUE)
#'                   
#' 
#' @export 
bootstrapRCR <- function(y, x, beta) {
    .Call('_BLRCR_bootstrapRCR', PACKAGE = 'BLRCR', y, x, beta)
}

#' Bayesian Logistic Regression Capture-Recapture using Conditional Likelihood
#' 
#' This function computes the Bayesian Logistic Regression Capture-Recapture estimate for N
#' using the conditional maximum likelihood (instead of the full likelihood).
#' 
#' @param y a nxj matrix of capture patterns.
#' @param x a nxh matrix of covariates.
#' @param priorb a (h+1) vector of prior means for the coefficients
#' @param priorB a (h+1)x(h+1) covariance matrix for the coefficients
#' 
#' @return List with components "N" and "beta". 
#' \describe{
#' \item{"N"}{is a single estimate of the population size.}
#' \item{"beta"}{is a matrix of beta estimates.}
#' }
#' 
#' @examples
#' #Generate the Data
#' mybeta = matrix(c(-2,-1,1,
#'                   -2,1,-1,
#'                   -2,-1,1,
#'                   -2,1,-1),nrow=4,byrow=TRUE)
#'                   
#' mynormprobs=c(0.3,0.4,0.3)
#' 
#' mynormmeans=matrix(c(2,2,
#'                      0,0,
#'                      -2,-2),ncol=2,byrow=TRUE)
#'                      
#' mynormsigma=matrix(c(.5,.45,.45,.5,
#'                       1,0,0,1,
#'                       .5,-.35,-.35,.5),nrow=3,byrow=TRUE)
#' 
#' myCRdata = multdatasimulator(2000,mybeta,mynormprobs,mynormmeans,mynormsigma,
#'                              missing=TRUE)
#'                            
#' #Run the Algorithm
#' mypriorb=rep(0,3) #prior on intercept and both beta means set to 0
#' mypriorB=diag(3) #identity matrix, size 3     
#' 
#' condBLRCRsolver(as.matrix(myCRdata[,1:4]),
#'                 as.matrix(myCRdata[,5:6]),mypriorb,mypriorB)                      
#' 
#' @export 
condBLRCRsolver <- function(y, x, priorb, priorB, gradparam = 0.01, prior = 1L, tol = 1e-6, maxiter = 1000L, initbeta = NULL) {
    .Call('_BLRCR_condBLRCRsolver', PACKAGE = 'BLRCR', y, x, priorb, priorB, gradparam, prior, tol, maxiter, initbeta)
}

